# 🛠 Decorator Pattern (데코레이터 패턴)

데코레이터 패턴(Decorator Pattern)은 **기존 객체의 기능을 확장하면서도 원래 객체의 구조를 변경하지 않는 디자인 패턴**입니다.
핵심 개념은 **객체를 감싸는(wrapper) 방식으로 동적으로 새로운 기능을 추가하는 것**입니다.

이 패턴을 사용하면 **클래스 상속 없이도 기능을 확장할 수 있으며**, 여러 개의 데코레이터를 조합하여 유연한 기능 확장이 가능합니다.

---

## 📌 구조 (Structure)

### 🔹 1. 기본 구성 요소

1. **Component (컴포넌트, 인터페이스)**: 기본 인터페이스로, 데코레이터와 실제 객체가 동일한 타입을 유지할 수 있도록 함.
2. **ConcreteComponent (구체적인 컴포넌트)**: 실제 동작을 수행하는 클래스.
3. **Decorator (데코레이터, 추상 클래스)**: `Component`를 감싸며, 추가 기능을 위한 기반을 제공.
4. **ConcreteDecorator (구체적인 데코레이터)**: `Decorator`를 상속받아 기능을 동적으로 추가하는 역할.

## 🎯 데코레이터 패턴의 특징과 장점

✅ **기능 확장 용이**: 상속 없이도 기존 객체의 기능을 확장 가능  
✅ **OCP (Open-Closed Principle) 준수**: 기존 코드를 변경하지 않고 새로운 기능 추가 가능  
✅ **유연한 조합 가능**: 여러 데코레이터를 조합하여 다양한 기능을 동적으로 적용 가능  
✅ **클래스 수 감소**: 기능 확장을 위한 서브클래스를 무한히 만들 필요 없이, 조합을 통해 재사용 가능

---

## 📊 데코레이터 패턴 vs. 상속 (Inheritance)

| 항목           | 데코레이터 패턴                    | 상속 (Inheritance)                 |
| -------------- | ---------------------------------- | ---------------------------------- |
| 기능 확장 방식 | 객체를 감싸서 기능 추가            | 서브클래스를 생성하여 기능 추가    |
| 유연성         | 매우 유연 (런타임 조합 가능)       | 제한적 (컴파일 타임에 결정됨)      |
| 유지보수성     | 기존 코드 변경 없이 기능 추가 가능 | 새로운 기능 추가 시 클래스 수 증가 |

---

## 💡 데코레이터 패턴을 적용하는 경우 (When to Use?)

- ✅ 객체의 기능을 **동적으로 추가/변경**해야 할 때
- ✅ **기능 확장을 위해 상속을 사용하는 것이 적절하지 않을 때** (클래스 폭발 방지)
- ✅ 런타임에 여러 조합을 통해 **유연한 기능 추가**가 필요할 때

---

## 🏆 결론 (Conclusion)

데코레이터 패턴은 **기존 객체를 변경하지 않으면서 새로운 기능을 추가할 수 있는 강력한 디자인 패턴**입니다.
상속의 한계를 극복하고, 조합을 통해 확장성을 높일 수 있어 **유지보수성과 확장성**이 뛰어난 코드 작성을 가능하게 합니다! 🚀
